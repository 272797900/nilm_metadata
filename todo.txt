## The Idea:
The schema in the schema directory describes the complete schema for meters and
appliances.

To assemble this complete data per appliance/meter in-memory, we traverse
the following hierarchy.  i.e. if we find an appliance instance 
which is a subtype of "Refrigeration:Samsung:RSH7UNBP" then we first
follow the tree to the top.  Then, starting from the top, we form a set of
key:value pairs where subclasses override previous values (just use dict.update).


* keep nilm_metadata as a separate project
  * the workflow will be:
    * publish both 'minimal' and 'full' versions of the metadata
    * at least to start with, nilmtk will use the 'full' version
    * and nilm_metadata will be a separate project responsible for:
      * validating schema
      * producing 'full' metadata       
      * producing 'minimal + catalogue' metadata
    * later, NILMTK can learn to use nilm_metadata directly and to
      store the object hierarchy in memory, perhaps as a DAG.

TODO:

* copy details from schema/appliance_old.json and old/

* finish convert_ukpd.py.
  * check that we don't have more than one instance per name
  * convert info from my README and my various metadata files on
    on_power_threshold etc
  * email to UKERC EDC

* test with details in my spreadsheet sketch of ideas.        

* tool to generate graphical model of relationship between objects in
  /objects and also in a dataset metadata

* write docs 
  * auto doc generation from json schema
  * how to write your own schema
  * how to concatenate it (need to think of a better name)
  * how to validate it
  * given that we allow a list of priors, and we allow these 
    to accumulate down the inheritance tree, we
    label these priors to say if they are specific to this
    object or to an ancestor, and how distant the ancestor is.
  * enforce appliance names
  * categories.  Tranditional, electrical, google shopping (links)
  * look through "done"

* tidy up

* tag with v0.1.0 and add a link to my UKPD metadata to https://github.com/nilmtk/nilm_metadata/tree/v0.1.0

* write paper for IEEE Workshop on Interopability in Scientific
  Computing (deadline = 23rd Mar) (see google doc for outline of paper)
* write papers for NILM Workshop

* check out Wiki Energy and email them if NILM Schema might be of use.
* tweet about it


IF TIME:
-------

* Test it out on HES column names

* have a "generated" folder for a graph showing hierarchy.  



DONE:

* Dataset schema.
  * look at http://blogs.nature.com/scientificdata/2014/01/08/scientific-datas-metadata-specification/

* look at http://schema.datacite.org/

* where to find a canonical list of country names?

* dataset version (JSON Meta-Schema???)

* briefly explore putting all schemas into a single YAML/JSON file???

* continue building out object_concatenation.py to implement all the
  new features in our new system:

* try to find an authoritive source for 
  appliance categories.  Google "hot cold ict wet appliance categories"

* Move all information from schema/appliance_old.json to
  classes/appliance_classes.json. Only have 'misc' left to do.  Tricky
  categorising them.  Should look at HES categorisations for these.

* also replace the following existing categories: 
  space heating -> "hot" + "climate control"
  space cooling -> "cold" + "climate control", 
  water heating -> "hot" + "wet"

* read and use the distributions in http://arxiv.org/pdf/1306.0802.pdf

* Check categories are valid JSON and that they all run through my
  code, at this point I might as well shove them into a graphical
  model for display!

* come up with a canonical list of categories:
  * ones used in HES
  * ones used in wikipedia
* maybe "classes" isn't a good name.  "object_hierarchy"?  "objects"?
  "hierarchy"?  "appliance_hierarchy"?



* work on convert_ukpd.py to get UKPD fully converted
  * automatically infer 'meter_ids' from 'original_name'
  * multiple, sequential kitchen lighting configs


* propagate nominal_voltage from dataset to building/electric

* Inheritance for meters

* Building schema
  * implement "do_not_inherit"
  * synonyms never inherited

* Get it working with appliance_catalogue
* Build functionality so we can just specify the name and find the
  class from the name.

* maybe have a separate file for listing synonyms for each appliance
  name.  This would be used to automatically import each dataset.
  Although that's what the "original_name" field is for.

* types:
  * check the instance does not specify non-allowed types
  * insert correct subtype into the inheritance hierarchy

* implement inheriting from appliance catalogue

* components
  * instantiate components.
  * uncomment components in test_appliance_group/components
  * check that the instance doesn't specify any components not in
    additional_components_allowed

  * collect together all components from default_components and
    components specified in instance.  Update default components.

* check the inheritance hierarchy runs in the correct direction!
* Build the code to traverse the class hierarchy 
* look at JavaScript inheritance mechanism
  * yes, our inheritance is a little like JS prototypical inheritance
    http://www.htmlgoodies.com/html5/tutorials/javascript-prototypical-inheritance-explained.html#fbid=Poq4adKWLGy
    Our properties are overriden / updated...
        lists get extended
        dictionaries get updated
        all other types are replaced
* Look again at SQLite.  EER generalisation. Can't do inheritance?
  Lots of empty fields?
  - Yes, we can do inheritance, but it doesn't feel like the right way
    to go... http://stackoverflow.com/a/3579462/732596



------------

* the object hierarchy should be represented in-memory in NILMTK (by a DAG?) 
  * but only load the objects required by the dataset
  * dynamically concatenate each object on demand???  using properties?

PROs and CONs of scenario where nilm_metadata is a separate project
which is responsible for validation and for producing a 'concatenated'
metadata output:

PROS:
  * keeps the metadata simple in nilmtk
  * allows 3rd party tools to use the metadata easily
  * allows users to see what's going on with the metadata

CONS:
  * if a parent changes then metadata needs to be
    re-compiled by nilm_metadata, e.g. if priors change
  * no elegant way for nilmtk to produce metadata (e.g. if we
    want to save to disk a subset of appliances).
  * repetition
