## The Idea:
The schema in the schema directory describes the complete schema for meters and
appliances.

To assemble this complete data per appliance/meter in-memory, we traverse
the following hierarchy.  i.e. if we find an appliance instance 
which is a subtype of "Refrigeration:Samsung:RSH7UNBP" then we first
follow the tree to the top.  Then, starting from the top, we form a set of
key:value pairs where subclasses override previous values (just use dict.update).


TODO:

* continue building out resolve_yaml_appliance.py to implement all the
  new features in our new system:

  * synonyms never inherited
  * implement "do_not_inherit"

  * allow multiple inheritance

  * test with details in my spreadsheet sketch of ideas.

  * given that we allow a list of priors, and we allow these 
    to accumulate down the inheritance tree, we probably need
    to label these priors to say if they are specific to this
    object or to an ancestor, and how distant the ancestor is.

  * enforce appliance names

* try to find an authoritive source for 
  appliance categories.  Google "hot cold ict wet appliance categories"

* Move all information from schema/appliance_old.json to
  classes/appliance_classes.json. Only have 'misc' left to do.  Tricky
  categorising them.  Should look at HES categorisations for these.

* also replace the following existing categories: 
  space heating -> "hot" + "climate control"
  space cooling -> "cold" + "climate control", 
  water heating -> "hot" + "wet"

* read and use the distributions in http://arxiv.org/pdf/1306.0802.pdf

* Check categories are valid JSON and that they all run through my
  code, at this point I might as well shove them into a graphical
  model for display!
* Do data for meters, using same pattern
* Building schema
* Dataset schema.
  * where to find a canonical list of country names?
  * look at http://schema.datacite.org/
  * and look at UKERC EDC's schemas
* come up with a canonical list of categories:
  * ones used in HES
  * ones used in wikipedia
* maybe "classes" isn't a good name.  "object_hierarchy"?  "objects"?
  "hierarchy"?  "appliance_hierarchy"?
* Test it out on HES column names
* Write my UKPD metadata
* have a "generated" folder for a graph showing hierarchy.  
* Write docs
* Make it work with nilmtk
  * original name should come from original dataset


DONE:

* Get it working with appliance_catalogue
* Build functionality so we can just specify the name and find the
  class from the name.

* maybe have a separate file for listing synonyms for each appliance
  name.  This would be used to automatically import each dataset.
  Although that's what the "original_name" field is for.

* types:
  * check the instance does not specify non-allowed types
  * insert correct subtype into the inheritance hierarchy

* implement inheriting from appliance catalogue

* components
  * instantiate components.
  * uncomment components in test_appliance_group/components
  * check that the instance doesn't specify any components not in
    additional_components_allowed

  * collect together all components from default_components and
    components specified in instance.  Update default components.

* check the inheritance hierarchy runs in the correct direction!
* Build the code to traverse the class hierarchy 
* look at JavaScript inheritance mechanism
  * yes, our inheritance is a little like JS prototypical inheritance
    http://www.htmlgoodies.com/html5/tutorials/javascript-prototypical-inheritance-explained.html#fbid=Poq4adKWLGy
    Our properties are overriden / updated...
        lists get extended
        dictionaries get updated
        all other types are replaced
* Look again at SQLite.  EER generalisation. Can't do inheritance?
  Lots of empty fields?
  - Yes, we can do inheritance, but it doesn't feel like the right way
    to go... http://stackoverflow.com/a/3579462/732596



------------

